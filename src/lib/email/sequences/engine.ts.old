/**
 * Email Sequence Engine
 * Motor de automação de sequências de email
 */

import { Resend } from 'resend'
import { createClient } from '@supabase/supabase-js'
import type {
  EmailSequence,
  SequenceSubscription,
  SequenceStep,
  SequenceTriggerData,
  SendEmailOptions,
  EmailEvent,
  SequenceStatus,
} from './types'

const resend = new Resend(process.env.RESEND_API_KEY)

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export class EmailSequenceEngine {
  /**
   * Subscreve um lead/usuário a uma sequência
   */
  async subscribe(
    sequenceId: string,
    data: SequenceTriggerData
  ): Promise<SequenceSubscription> {
    // Verificar se já existe subscription para este lead
    const { data: existing } = await supabase
      .from('email_sequence_subscriptions')
      .select('*')
      .eq('lead_id', data.leadId)
      .eq('sequence_id', sequenceId)
      .single()

    if (existing && existing.status === 'active') {
      console.log('[EmailSequenceEngine] Lead already subscribed:', data.email)
      return this.mapToSubscription(existing)
    }

    // Criar nova subscription no banco
    const { data: inserted, error } = await supabase
      .from('email_sequence_subscriptions')
      .insert({
        lead_id: data.leadId,
        sequence_id: sequenceId,
        current_step_id: null,
        status: 'active',
        subscribed_at: new Date().toISOString(),
        metadata: {
          userId: data.userId,
          email: data.email,
          firstName: data.firstName,
          lastName: data.lastName,
          ...data.customData,
        },
      })
      .select()
      .single()

    if (error) {
      console.error('[EmailSequenceEngine] Failed to subscribe:', error)
      throw new Error(`Failed to subscribe: ${error.message}`)
    }

    console.log('[EmailSequenceEngine] Subscribed:', data.email, 'to sequence:', sequenceId)

    const subscription = this.mapToSubscription(inserted)

    // Agendar primeiro email da sequência
    await this.scheduleNextStep(subscription)

    return subscription
  }

  /**
   * Agenda o próximo step de uma subscription
   */
  async scheduleNextStep(subscription: SequenceSubscription): Promise<void> {
    // TODO: Buscar sequência do banco
    // TODO: Determinar próximo step baseado em currentStepId
    // TODO: Agendar email com delay correto

    console.log(
      '[EmailSequenceEngine] Scheduling next step for subscription:',
      subscription.id
    )

    // Por enquanto, apenas loga
    // Implementação real usará cron job ou queue (Inngest, BullMQ, etc.)
  }

  /**
   * Envia um email de uma sequência
   */
  async sendSequenceEmail(
    subscription: SequenceSubscription,
    step: SequenceStep,
    template: { subject: string; html: string; text?: string }
  ): Promise<EmailEvent> {
    const variables = this.buildVariables(subscription)
    const subject = this.replaceVariables(template.subject, variables)
    const html = this.replaceVariables(template.html, variables)
    const text = template.text ? this.replaceVariables(template.text, variables) : undefined

    const emailOptions: SendEmailOptions = {
      to: subscription.email,
      from: process.env.RESEND_FROM_EMAIL || 'contato@garcezpalha.com',
      replyTo: 'contato@garcezpalha.com',
      subject,
      html,
      text,
      tags: ['sequence', step.sequenceId, `step-${step.order}`],
      headers: {
        'X-Subscription-ID': subscription.id,
        'X-Step-ID': step.id,
      },
    }

    try {
      const result = await resend.emails.send(emailOptions)

      const event: EmailEvent = {
        id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        subscriptionId: subscription.id,
        stepId: step.id,
        type: 'sent',
        emailProvider: 'resend',
        providerId: result.data?.id || '',
        metadata: { result },
        createdAt: new Date(),
      }

      console.log('[EmailSequenceEngine] Email sent:', event.id, 'to:', subscription.email)

      // TODO: Salvar event no banco
      // TODO: Atualizar subscription.currentStepId
      // TODO: Atualizar subscription.lastEmailSentAt

      return event
    } catch (error) {
      console.error('[EmailSequenceEngine] Failed to send email:', error)

      const event: EmailEvent = {
        id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        subscriptionId: subscription.id,
        stepId: step.id,
        type: 'bounced',
        emailProvider: 'resend',
        providerId: '',
        metadata: { error: (error as Error).message },
        createdAt: new Date(),
      }

      // TODO: Salvar event no banco
      return event
    }
  }

  /**
   * Cancela uma subscription
   */
  async unsubscribe(subscriptionId: string): Promise<void> {
    // TODO: Atualizar subscription no banco
    // subscription.status = 'cancelled'
    // subscription.cancelledAt = new Date()

    console.log('[EmailSequenceEngine] Unsubscribed:', subscriptionId)
  }

  /**
   * Processa webhooks de email providers (open, click, bounce, etc.)
   */
  async handleWebhook(
    provider: 'resend',
    event: {
      type: string
      email: string
      subscriptionId: string
      stepId: string
      link?: string
    }
  ): Promise<void> {
    console.log('[EmailSequenceEngine] Webhook received:', event.type, 'for:', event.email)

    const emailEvent: EmailEvent = {
      id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      subscriptionId: event.subscriptionId,
      stepId: event.stepId,
      type: event.type as any,
      emailProvider: provider,
      providerId: '',
      metadata: { link: event.link },
      createdAt: new Date(),
    }

    // TODO: Salvar event no banco
    // TODO: Atualizar stats da sequência
    // TODO: Se opened/clicked, disparar próximo step baseado em conditions
  }

  /**
   * Constrói variáveis para substituição no template
   */
  private buildVariables(subscription: SequenceSubscription): Record<string, string> {
    return {
      firstName: subscription.firstName || '',
      lastName: subscription.lastName || '',
      email: subscription.email,
      ...subscription.customData,
      unsubscribeLink: `https://garcezpalha.com/unsubscribe/${subscription.id}`,
    }
  }

  /**
   * Substitui variáveis no template ({{variable}})
   */
  private replaceVariables(template: string, variables: Record<string, string>): string {
    let result = template

    Object.keys(variables).forEach((key) => {
      const regex = new RegExp(`{{${key}}}`, 'g')
      result = result.replace(regex, variables[key] || '')
    })

    return result
  }

  /**
   * Calcula stats de uma sequência
   */
  async calculateStats(sequenceId: string): Promise<{
    totalSubscribers: number
    activeSubscribers: number
    completedSubscribers: number
    totalEmailsSent: number
    totalOpens: number
    totalClicks: number
    openRate: number
    clickRate: number
  }> {
    // TODO: Query do banco para calcular stats reais
    // Por enquanto, retorna mock

    return {
      totalSubscribers: 0,
      activeSubscribers: 0,
      completedSubscribers: 0,
      totalEmailsSent: 0,
      totalOpens: 0,
      totalClicks: 0,
      openRate: 0,
      clickRate: 0,
    }
  }

  /**
   * Processa emails agendados (chamado por cron job)
   * TODO: Implementar com banco de dados real
   */
  async processScheduledEmails(): Promise<{
    activeSubscriptions: number
    emailsSent: number
    emailsScheduled: number
    errors: number
  }> {
    // TODO: Query subscriptions ativas do Supabase
    // TODO: Verificar próximo email agendado
    // TODO: Enviar emails que chegaram no horário

    console.log('[EmailSequenceEngine] Processing scheduled emails (mock)')

    return {
      activeSubscriptions: 0,
      emailsSent: 0,
      emailsScheduled: 0,
      errors: 0,
    }
  }
}

export const emailSequenceEngine = new EmailSequenceEngine()

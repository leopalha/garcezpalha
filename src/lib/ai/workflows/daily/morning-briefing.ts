/**
 * Morning Briefing Workflow
 * Daily executive briefing generated by CEO Agent
 * Aggregates data from all departments for strategic overview
 */

import type {
  WorkflowConfig,
  WorkflowExecution,
  WorkflowResult,
  WorkflowStep,
  MorningBriefingInput,
  MorningBriefingOutput,
} from '../types'
import { getCEOAgent } from '../../agents/executive/ceo-agent'
import { getCFOAgent } from '../../agents/executive/cfo-agent'
import { getCMOAgent } from '../../agents/executive/cmo-agent'
import { getCOOAgent } from '../../agents/executive/coo-agent'
import { createAgentLogger } from '../../agents/core/agent-logger'

// =============================================================================
// WORKFLOW CONFIGURATION
// =============================================================================

export const MORNING_BRIEFING_CONFIG: WorkflowConfig = {
  id: 'morning-briefing',
  name: 'Morning Briefing',
  description: 'Relat√≥rio executivo di√°rio com m√©tricas, alertas e prioridades',
  frequency: 'daily',
  priority: 'high',
  enabled: true,
  schedule: '0 8 * * 1-5', // 8h de segunda a sexta
  timeout: 300000, // 5 minutos
  retryOnFailure: true,
  maxRetries: 2,
  notifyOnComplete: true,
  notifyOnFailure: true,
}

// =============================================================================
// WORKFLOW IMPLEMENTATION
// =============================================================================

const logger = createAgentLogger('ceo', 'executive')

export class MorningBriefingWorkflow {
  private execution: WorkflowExecution | null = null
  private steps: WorkflowStep[] = []

  /**
   * Execute the morning briefing workflow
   */
  async execute(input: MorningBriefingInput): Promise<WorkflowResult> {
    const startTime = Date.now()

    this.execution = {
      id: `exec_${Date.now()}`,
      workflowId: MORNING_BRIEFING_CONFIG.id,
      status: 'running',
      steps: [],
      startedAt: new Date(),
      triggeredBy: 'schedule',
    }

    logger.info('workflow-start', 'Morning Briefing iniciando', { date: input.date })

    try {
      // Step 1: Gather financial data
      const financialData = await this.executeStep('financial-data', 'cfo', async () => {
        const cfo = getCFOAgent()
        return await cfo.analyzeCashFlow({
          period: 'day',
          includeProjections: true,
        })
      })

      // Step 2: Gather marketing data
      const marketingData = await this.executeStep('marketing-data', 'cmo', async () => {
        const cmo = getCMOAgent()
        return await cmo.analyzeChannelPerformance({
          period: 'day',
          channels: ['google_ads', 'meta_ads', 'organic', 'social'],
        })
      })

      // Step 3: Gather operations data
      const operationsData = await this.executeStep('operations-data', 'coo', async () => {
        const coo = getCOOAgent()
        return await coo.generateOperationsDashboard({
          date: input.date,
          includeAgentStatus: true,
        })
      })

      // Step 4: Generate executive briefing
      const briefing = await this.executeStep('generate-briefing', 'ceo', async () => {
        const ceo = getCEOAgent()
        return await ceo.generateDailyBriefing({
          date: input.date,
          financialSummary: financialData,
          marketingSummary: marketingData,
          operationsSummary: operationsData,
        })
      })

      // Process and format output
      const output = this.formatBriefingOutput(briefing, input)

      this.execution.status = 'completed'
      this.execution.completedAt = new Date()
      this.execution.duration = Date.now() - startTime

      logger.info('workflow-complete', 'Morning Briefing conclu√≠do', {
        duration: this.execution.duration,
        stepsCompleted: this.steps.filter(s => s.status === 'completed').length,
      })

      return {
        success: true,
        summary: `Briefing di√°rio gerado com sucesso para ${input.date.toLocaleDateString('pt-BR')}`,
        outputs: { briefing: output },
        metrics: {
          stepsCompleted: this.steps.filter(s => s.status === 'completed').length,
          stepsFailed: this.steps.filter(s => s.status === 'failed').length,
          totalDuration: this.execution.duration,
          agentsUsed: ['ceo', 'cfo', 'cmo', 'coo'],
        },
        nextActions: this.generateNextActions(output),
      }
    } catch (error) {
      this.execution.status = 'failed'
      this.execution.error = error instanceof Error ? error.message : 'Unknown error'
      this.execution.completedAt = new Date()
      this.execution.duration = Date.now() - startTime

      logger.error('workflow-failed', 'Morning Briefing falhou', error as Error)

      return {
        success: false,
        summary: `Erro ao gerar briefing: ${this.execution.error}`,
        outputs: {},
        metrics: {
          stepsCompleted: this.steps.filter(s => s.status === 'completed').length,
          stepsFailed: this.steps.filter(s => s.status === 'failed').length,
          totalDuration: this.execution.duration,
          agentsUsed: this.steps.map(s => s.agent),
        },
      }
    }
  }

  /**
   * Execute a workflow step with error handling
   */
  private async executeStep<T>(
    stepId: string,
    agent: 'ceo' | 'cfo' | 'cmo' | 'coo',
    action: () => Promise<T>
  ): Promise<T> {
    const step: WorkflowStep = {
      id: stepId,
      name: stepId.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
      agent,
      action: stepId,
      status: 'running',
      startedAt: new Date(),
    }

    this.steps.push(step)

    try {
      const result = await action()
      step.status = 'completed'
      step.completedAt = new Date()
      step.result = result
      return result
    } catch (error) {
      step.status = 'failed'
      step.completedAt = new Date()
      step.error = error instanceof Error ? error.message : 'Unknown error'
      throw error
    }
  }

  /**
   * Format briefing output
   */
  private formatBriefingOutput(
    briefing: unknown,
    input: MorningBriefingInput
  ): MorningBriefingOutput {
    const data = briefing as Record<string, unknown>

    return {
      date: input.date.toISOString().split('T')[0],
      executiveSummary: (data.summary as string) || 'Briefing executivo do dia',
      keyMetrics: this.extractKeyMetrics(data),
      priorityTasks: this.extractPriorityTasks(data),
      activeAlerts: this.extractAlerts(data),
      todaySchedule: this.extractSchedule(data),
      recommendations: (data.recommendations as string[]) || [],
    }
  }

  /**
   * Extract key metrics from briefing data
   */
  private extractKeyMetrics(data: Record<string, unknown>): MorningBriefingOutput['keyMetrics'] {
    const metrics = data.metrics as Record<string, unknown>[] || []

    return [
      {
        category: 'Leads Novos',
        value: (metrics.find(m => m.category === 'leads') as Record<string, unknown>)?.value || 0,
        trend: 'stable' as const,
      },
      {
        category: 'Receita do Dia',
        value: (metrics.find(m => m.category === 'revenue') as Record<string, unknown>)?.value || 'R$ 0',
        trend: 'up' as const,
      },
      {
        category: 'Processos Ativos',
        value: (metrics.find(m => m.category === 'processes') as Record<string, unknown>)?.value || 0,
        trend: 'stable' as const,
      },
      {
        category: 'Taxa de Convers√£o',
        value: (metrics.find(m => m.category === 'conversion') as Record<string, unknown>)?.value || '0%',
        trend: 'up' as const,
      },
    ]
  }

  /**
   * Extract priority tasks from briefing data
   */
  private extractPriorityTasks(data: Record<string, unknown>): MorningBriefingOutput['priorityTasks'] {
    const tasks = data.tasks as Record<string, unknown>[] || []

    return tasks.slice(0, 5).map((task, index) => ({
      id: `task_${index}`,
      title: (task.title as string) || 'Tarefa pendente',
      priority: (task.priority as 'low' | 'medium' | 'high' | 'critical') || 'medium',
      deadline: task.deadline as string,
      assignedTo: task.assignedTo as 'ceo' | 'cfo' | 'cmo' | 'coo',
    }))
  }

  /**
   * Extract alerts from briefing data
   */
  private extractAlerts(data: Record<string, unknown>): MorningBriefingOutput['activeAlerts'] {
    const alerts = data.alerts as Record<string, unknown>[] || []

    return alerts.map((alert, index) => ({
      id: `alert_${index}`,
      title: (alert.title as string) || 'Alerta',
      severity: (alert.severity as 'info' | 'warning' | 'critical') || 'info',
      action: (alert.action as string) || 'Verificar',
    }))
  }

  /**
   * Extract schedule from briefing data
   */
  private extractSchedule(data: Record<string, unknown>): MorningBriefingOutput['todaySchedule'] {
    const schedule = data.schedule as Record<string, unknown>[] || []

    return schedule.map(event => ({
      time: (event.time as string) || '00:00',
      event: (event.title as string) || 'Evento',
      type: (event.type as string) || 'meeting',
    }))
  }

  /**
   * Generate next actions based on briefing
   */
  private generateNextActions(output: MorningBriefingOutput) {
    const actions = []

    // Check for critical alerts
    const criticalAlerts = output.activeAlerts.filter(a => a.severity === 'critical')
    if (criticalAlerts.length > 0) {
      actions.push({
        type: 'escalate' as const,
        target: 'admin',
        payload: { alerts: criticalAlerts },
        priority: 'critical' as const,
      })
    }

    // Schedule notifications
    actions.push({
      type: 'notify' as const,
      target: 'telegram',
      payload: {
        message: this.formatTelegramMessage(output),
        recipients: ['admin'],
      },
      priority: 'high' as const,
    })

    return actions
  }

  /**
   * Format message for Telegram notification
   */
  private formatTelegramMessage(output: MorningBriefingOutput): string {
    const lines = [
      `üìä *Briefing Di√°rio - ${output.date}*`,
      '',
      output.executiveSummary,
      '',
      '*M√©tricas Principais:*',
    ]

    for (const metric of output.keyMetrics) {
      const trendIcon = metric.trend === 'up' ? 'üìà' : metric.trend === 'down' ? 'üìâ' : '‚û°Ô∏è'
      lines.push(`${trendIcon} ${metric.category}: ${metric.value}`)
    }

    if (output.activeAlerts.length > 0) {
      lines.push('')
      lines.push('*Alertas Ativos:*')
      for (const alert of output.activeAlerts) {
        const icon = alert.severity === 'critical' ? 'üî¥' : alert.severity === 'warning' ? 'üü°' : 'üîµ'
        lines.push(`${icon} ${alert.title}`)
      }
    }

    if (output.priorityTasks.length > 0) {
      lines.push('')
      lines.push('*Tarefas Priorit√°rias:*')
      for (const task of output.priorityTasks.slice(0, 3)) {
        lines.push(`‚Ä¢ ${task.title}`)
      }
    }

    return lines.join('\n')
  }

  /**
   * Get current execution status
   */
  getStatus() {
    return this.execution?.status || 'pending'
  }

  /**
   * Get current execution details
   */
  getExecution() {
    return this.execution
  }

  /**
   * Cancel the workflow
   */
  async cancel() {
    if (this.execution && this.execution.status === 'running') {
      this.execution.status = 'cancelled'
      this.execution.completedAt = new Date()
      logger.info('workflow-cancelled', 'Morning Briefing cancelado')
    }
  }
}

// =============================================================================
// FACTORY FUNCTIONS
// =============================================================================

/**
 * Create a new Morning Briefing workflow instance
 */
export function createMorningBriefingWorkflow(): MorningBriefingWorkflow {
  return new MorningBriefingWorkflow()
}

/**
 * Execute morning briefing with default options
 */
export async function executeMorningBriefing(
  options?: Partial<MorningBriefingInput>
): Promise<WorkflowResult> {
  const workflow = createMorningBriefingWorkflow()

  const input: MorningBriefingInput = {
    date: options?.date || new Date(),
    includeMetrics: options?.includeMetrics ?? true,
    includeTasks: options?.includeTasks ?? true,
    includeAlerts: options?.includeAlerts ?? true,
    includeSchedule: options?.includeSchedule ?? true,
  }

  return workflow.execute(input)
}

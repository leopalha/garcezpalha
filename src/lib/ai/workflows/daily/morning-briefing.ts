/**
 * Morning Briefing Workflow
 * Daily executive briefing generated by CEO Agent
 * Aggregates data from all departments for strategic overview
 */

import type {
  WorkflowConfig,
  WorkflowExecution,
  WorkflowResult,
  WorkflowStep,
  MorningBriefingInput,
  MorningBriefingOutput,
  WorkflowPriority,
} from '../types'
import type { AgentRole } from '../../agents/core/agent-types'
import { createAgentLogger } from '../../agents/core/agent-logger'

// =============================================================================
// WORKFLOW CONFIGURATION
// =============================================================================

export const MORNING_BRIEFING_CONFIG: WorkflowConfig = {
  id: 'morning-briefing',
  name: 'Morning Briefing',
  description: 'Relat√≥rio executivo di√°rio com m√©tricas, alertas e prioridades',
  frequency: 'daily',
  priority: 'high',
  enabled: true,
  schedule: '0 8 * * 1-5', // 8h de segunda a sexta
  timeout: 300000, // 5 minutos
  retryOnFailure: true,
  maxRetries: 2,
  notifyOnComplete: true,
  notifyOnFailure: true,
}

// =============================================================================
// WORKFLOW IMPLEMENTATION
// =============================================================================

const logger = createAgentLogger('ceo', 'executive')

export class MorningBriefingWorkflow {
  private execution: WorkflowExecution | null = null
  private steps: WorkflowStep[] = []

  /**
   * Execute the morning briefing workflow
   */
  async execute(input: MorningBriefingInput): Promise<WorkflowResult> {
    const startTime = Date.now()

    this.execution = {
      id: `exec_${Date.now()}`,
      workflowId: MORNING_BRIEFING_CONFIG.id,
      status: 'running',
      steps: [],
      startedAt: new Date(),
      triggeredBy: 'schedule',
    }

    logger.info('workflow-start', 'Morning Briefing iniciando', { date: input.date })

    try {
      // Step 1: Gather financial data
      const financialData = await this.executeStep('financial-data', 'cfo', async () => {
        // Simulated financial data - in production, would call CFO agent
        return this.gatherFinancialData()
      })

      // Step 2: Gather marketing data
      const marketingData = await this.executeStep('marketing-data', 'cmo', async () => {
        // Simulated marketing data - in production, would call CMO agent
        return this.gatherMarketingData()
      })

      // Step 3: Gather operations data
      const operationsData = await this.executeStep('operations-data', 'coo', async () => {
        // Simulated operations data - in production, would call COO agent
        return this.gatherOperationsData()
      })

      // Step 4: Generate executive briefing
      const briefing = await this.executeStep('generate-briefing', 'ceo', async () => {
        return this.generateBriefing(financialData, marketingData, operationsData, input)
      })

      // Process and format output
      const output = this.formatBriefingOutput(briefing, input)

      this.execution.status = 'completed'
      this.execution.completedAt = new Date()
      this.execution.duration = Date.now() - startTime

      logger.info('workflow-complete', 'Morning Briefing conclu√≠do', {
        duration: this.execution.duration,
        stepsCompleted: this.steps.filter(s => s.status === 'completed').length,
      })

      return {
        success: true,
        summary: `Briefing di√°rio gerado com sucesso para ${input.date.toLocaleDateString('pt-BR')}`,
        outputs: { briefing: output },
        metrics: {
          stepsCompleted: this.steps.filter(s => s.status === 'completed').length,
          stepsFailed: this.steps.filter(s => s.status === 'failed').length,
          totalDuration: this.execution.duration,
          agentsUsed: ['ceo', 'cfo', 'cmo', 'coo'] as AgentRole[],
        },
        nextActions: this.generateNextActions(output),
      }
    } catch (error) {
      this.execution.status = 'failed'
      this.execution.error = error instanceof Error ? error.message : 'Unknown error'
      this.execution.completedAt = new Date()
      this.execution.duration = Date.now() - startTime

      logger.error('workflow-failed', 'Morning Briefing falhou', error as Error)

      return {
        success: false,
        summary: `Erro ao gerar briefing: ${this.execution.error}`,
        outputs: {},
        metrics: {
          stepsCompleted: this.steps.filter(s => s.status === 'completed').length,
          stepsFailed: this.steps.filter(s => s.status === 'failed').length,
          totalDuration: this.execution.duration,
          agentsUsed: this.steps.map(s => s.agent as AgentRole),
        },
      }
    }
  }

  /**
   * Execute a workflow step with error handling
   */
  private async executeStep<T>(
    stepId: string,
    agent: AgentRole,
    action: () => Promise<T>
  ): Promise<T> {
    const step: WorkflowStep = {
      id: stepId,
      name: stepId.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
      agent,
      action: stepId,
      status: 'running',
      startedAt: new Date(),
    }

    this.steps.push(step)

    try {
      const result = await action()
      step.status = 'completed'
      step.completedAt = new Date()
      step.result = result
      return result
    } catch (error) {
      step.status = 'failed'
      step.completedAt = new Date()
      step.error = error instanceof Error ? error.message : 'Unknown error'
      throw error
    }
  }

  /**
   * Gather financial data (simulated)
   */
  private async gatherFinancialData(): Promise<Record<string, unknown>> {
    // In production, this would query the database and/or call CFO agent
    return {
      cashFlow: { balance: 150000, trend: 'up' },
      receivables: { total: 45000, overdue: 5000 },
      revenue: { today: 3500, mtd: 75000 },
    }
  }

  /**
   * Gather marketing data (simulated)
   */
  private async gatherMarketingData(): Promise<Record<string, unknown>> {
    // In production, this would query analytics and/or call CMO agent
    return {
      leads: { today: 8, mtd: 120, trend: 'up' },
      conversion: { rate: 0.15, trend: 'stable' },
      channels: [
        { name: 'Google Ads', leads: 5, spend: 250 },
        { name: 'Org√¢nico', leads: 3, spend: 0 },
      ],
    }
  }

  /**
   * Gather operations data (simulated)
   */
  private async gatherOperationsData(): Promise<Record<string, unknown>> {
    // In production, this would query the database and/or call COO agent
    return {
      tasks: { pending: 15, completed: 8 },
      processes: { active: 45, newToday: 2 },
      sla: { compliance: 0.95 },
    }
  }

  /**
   * Generate briefing from gathered data
   */
  private generateBriefing(
    financial: Record<string, unknown>,
    marketing: Record<string, unknown>,
    operations: Record<string, unknown>,
    input: MorningBriefingInput
  ): Record<string, unknown> {
    const revenueValue = ((financial.revenue as Record<string, unknown>)?.today as number) || 0
    const conversionRate = ((marketing.conversion as Record<string, unknown>)?.rate as number) || 0

    return {
      summary: `Briefing executivo para ${input.date.toLocaleDateString('pt-BR')}. Sistema operando normalmente.`,
      metrics: [
        { category: 'leads', value: (marketing.leads as Record<string, unknown>)?.today || 0 },
        { category: 'revenue', value: `R$ ${revenueValue.toLocaleString('pt-BR')}` },
        { category: 'processes', value: (operations.processes as Record<string, unknown>)?.active || 0 },
        { category: 'conversion', value: `${(conversionRate * 100).toFixed(0)}%` },
      ],
      tasks: [
        { title: 'Revisar leads quentes', priority: 'high' },
        { title: 'Acompanhar processos urgentes', priority: 'high' },
        { title: 'Verificar cobran√ßas pendentes', priority: 'medium' },
      ],
      alerts: [],
      recommendations: [
        'Foco em convers√£o de leads quentes',
        'Manter acompanhamento de prazos processuais',
      ],
    }
  }

  /**
   * Format briefing output
   */
  private formatBriefingOutput(
    briefing: Record<string, unknown>,
    input: MorningBriefingInput
  ): MorningBriefingOutput {
    const metrics = briefing.metrics as Array<{ category: string; value: string | number }> || []

    return {
      date: input.date.toISOString().split('T')[0],
      executiveSummary: (briefing.summary as string) || 'Briefing executivo do dia',
      keyMetrics: metrics.map(m => ({
        category: m.category,
        value: m.value,
        trend: 'stable' as const,
      })),
      priorityTasks: ((briefing.tasks as Array<{ title: string; priority: string }>) || []).map((task, index) => ({
        id: `task_${index}`,
        title: task.title,
        priority: (task.priority as WorkflowPriority) || 'medium',
      })),
      activeAlerts: ((briefing.alerts as Array<{ title: string; severity: string }>) || []).map((alert, index) => ({
        id: `alert_${index}`,
        title: alert.title,
        severity: (alert.severity as 'info' | 'warning' | 'critical') || 'info',
        action: 'Verificar',
      })),
      todaySchedule: [],
      recommendations: (briefing.recommendations as string[]) || [],
    }
  }

  /**
   * Generate next actions based on briefing
   */
  private generateNextActions(output: MorningBriefingOutput) {
    const actions = []

    // Check for critical alerts
    const criticalAlerts = output.activeAlerts.filter(a => a.severity === 'critical')
    if (criticalAlerts.length > 0) {
      actions.push({
        type: 'escalate' as const,
        target: 'admin',
        payload: { alerts: criticalAlerts },
        priority: 'critical' as const,
      })
    }

    // Schedule notifications
    actions.push({
      type: 'notify' as const,
      target: 'telegram',
      payload: {
        message: this.formatTelegramMessage(output),
        recipients: ['admin'],
      },
      priority: 'high' as const,
    })

    return actions
  }

  /**
   * Format message for Telegram notification
   */
  private formatTelegramMessage(output: MorningBriefingOutput): string {
    const lines = [
      `üìä *Briefing Di√°rio - ${output.date}*`,
      '',
      output.executiveSummary,
      '',
      '*M√©tricas Principais:*',
    ]

    for (const metric of output.keyMetrics) {
      const trendIcon = metric.trend === 'up' ? 'üìà' : metric.trend === 'down' ? 'üìâ' : '‚û°Ô∏è'
      lines.push(`${trendIcon} ${metric.category}: ${metric.value}`)
    }

    if (output.activeAlerts.length > 0) {
      lines.push('')
      lines.push('*Alertas Ativos:*')
      for (const alert of output.activeAlerts) {
        const icon = alert.severity === 'critical' ? 'üî¥' : alert.severity === 'warning' ? 'üü°' : 'üîµ'
        lines.push(`${icon} ${alert.title}`)
      }
    }

    if (output.priorityTasks.length > 0) {
      lines.push('')
      lines.push('*Tarefas Priorit√°rias:*')
      for (const task of output.priorityTasks.slice(0, 3)) {
        lines.push(`‚Ä¢ ${task.title}`)
      }
    }

    return lines.join('\n')
  }

  /**
   * Get current execution status
   */
  getStatus() {
    return this.execution?.status || 'pending'
  }

  /**
   * Get current execution details
   */
  getExecution() {
    return this.execution
  }

  /**
   * Cancel the workflow
   */
  async cancel() {
    if (this.execution && this.execution.status === 'running') {
      this.execution.status = 'cancelled'
      this.execution.completedAt = new Date()
      logger.info('workflow-cancelled', 'Morning Briefing cancelado')
    }
  }
}

// =============================================================================
// FACTORY FUNCTIONS
// =============================================================================

/**
 * Create a new Morning Briefing workflow instance
 */
export function createMorningBriefingWorkflow(): MorningBriefingWorkflow {
  return new MorningBriefingWorkflow()
}

/**
 * Execute morning briefing with default options
 */
export async function executeMorningBriefing(
  options?: Partial<MorningBriefingInput>
): Promise<WorkflowResult> {
  const workflow = createMorningBriefingWorkflow()

  const input: MorningBriefingInput = {
    date: options?.date || new Date(),
    includeMetrics: options?.includeMetrics ?? true,
    includeTasks: options?.includeTasks ?? true,
    includeAlerts: options?.includeAlerts ?? true,
    includeSchedule: options?.includeSchedule ?? true,
  }

  return workflow.execute(input)
}
